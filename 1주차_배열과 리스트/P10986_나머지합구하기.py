# 시간 제한 1초 / 백준 10986번
# https://www.acmicpc.net/problem/10986

# 문제 분석 ----------------------------------------------------
# N의 최댓값이 10^6이라 연산량이 작게 느껴지지만, 1초 제한에 걸림
# 여러 번의 구간 합을 빠르게 구하기 위해, 합 배열 이용 
# (A+B)%C = ((A%C)+(B%C))%C
# 1) 구간 합 배열의 원소를 M으로 나눈 나머지로 업데이트 
# 2) S[j]와 S[i]가 같은 (i, j)쌍을 찾으면, 원본 배열의 구간 도출 가능
# 3) (i, j)쌍 도출 시엔 경우의 수 이용 (확정 + 조합 + 조합 + ... ) 
# --------------------------------------------------------------

# 슈도 코드 -----------------------------------------------------
# 수열 개수 n 입력
# 나누어 떨어져야 하는 수 m 입력
# 원본 수열 A 입력
# 합 배열 S 생성

# m으로 나눈 리스트 생성
# 같은 나머지 쌍 카운트 C 리스트 생성
# result 생성 

# for i = 1 ~ n-1:
#     S[i] = S[i-1] + A[i]

# 1) 나머지 값 0 카운트
# for i = 0 ~ n-1:
#     나머지값 = S[i] % m
#     if(나머지값 == 0) -> result += 1
#     C[나머지값] += 1 

# 2) 같은 쌍 경우의 수 카운트
# for i = 0 ~ m-1:
#    if C[i] > 1:
#    result += (C[i] * C[i]-1) // 2 
#     
# print(rseult)
# ----------------------------------------------------------------  

import sys
input = sys.stdin.readline

 
n, m = map(int, input().split()) # n, m 입력 받기
A = list(map(int, input().split())) # 원본 수열 입력 받기
S = [0] * n # 합 배열 선언
C = [0] * m # 같은 나머지의 인덱스 카운트하는 리스트 선언(m의 값을 초과하지 못함)
result = 0

# 합배열 생성
S[0] = A[0]
for i in range(1, n):
    S[i] = S[i-1] + A[i]
    
for i in range(n):
    remainder = S[i] % m
    if remainder == 0:
        result += 1
    C[remainder] += 1 # 같은 나머지 값만 추가되게!! ㅇㅋ 이해함 

for i in range(m):
    if C[i] > 1:
        result += (C[i] * (C[i]-1) // 2)
        
print(result) 


# 시간 복잡도 = O(N)